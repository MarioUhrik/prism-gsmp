//==============================================================================
//	
//	Copyright (c) 2018-
//	Authors:
//	* Mario Uhrik <433501@mail.muni.cz> (Masaryk University)
//	
//------------------------------------------------------------------------------
//	
//	This file is part of PRISM.
//	
//	PRISM is free software; you can redistribute it and/or modify
//	it under the terms of the GNU General Public License as published by
//	the Free Software Foundation; either version 2 of the License, or
//	(at your option) any later version.
//	
//	PRISM is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//	GNU General Public License for more details.
//	
//	You should have received a copy of the GNU General Public License
//	along with PRISM; if not, write to the Free Software Foundation,
//	Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//	
//==============================================================================

package explicit;

import java.math.BigDecimal;
import java.math.MathContext;
import java.math.RoundingMode;
import java.util.BitSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import ch.obermuhlner.math.big.BigDecimalMath;
import common.BigDecimalUtils;
import explicit.ProbModelChecker.LinEqMethod;
import explicit.rewards.ACTMCRewardsSimple;
import explicit.rewards.MCRewards;
import explicit.rewards.StateRewardsConstant;
import explicit.rewards.StateRewardsSimple;
import prism.Pair;
import prism.PrismComponent;
import prism.PrismDevNullLog;
import prism.PrismException;
import prism.PrismSettings;

/**
 * Class for reduction of ACTMC to equivalent DTMC. (and also their reward structures)
 * <br>
 * This class fulfills similar purpose to class {@code ACTMCPotatoData},
 * but on the scope of the entire ACTMC, whereas the scope of {@code ACTMCPotatoData}
 * only encompasses a single event.
 */
public class ACTMCReduction extends PrismComponent // TODO MAJO - optimize BigDecimal usage
{
	/** ACTMC model this class is associated with */
	private ACTMCSimple actmc;
	/** Optional reward structure associated with {@code actmc}.
	 *  The CTMC transition rewards are already expected to have been converted to state rewards.
	 *  May be null if rewards are not of interest for given model checking method.*/
	private ACTMCRewardsSimple actmcRew = null;
	/** Optional bitset of target states (for reachability) */
	private BitSet target = null;
	/** bitset of states of which each element:
	 *  1) either does not belong to any potato (no non-exponential event is active in it),
	 *  2) or it is an entrance to some potato. */
	private BitSet relevantStates;
	/** Map where the keys are string identifiers of the GSMPEvents,
	 *  and the values are corresponding ACTMCPotatoData structures.
	 *  This is useful for fast access and efficient reusage of the ACTMCPotatoData structures.*/
	private Map<String, ACTMCPotatoData> pdMap;
	/** DTMC equivalent to {@code actmc} eventually generated by this class.
	 *  Initially null.*/
	private DTMCSimple dtmc = null;
	private MCRewards dtmcRew = null;
	/** If this is true, the resulting dtmc and rewards are uniformized so that
	 *  each step of the dtmc corresponds to the same real time unit,
	 *  precisely 1/dtmc.uniformizationRate.
	 *  Generally, this should be true for Total Reward/Reachability reward
	 *  kind of computations, and false for Steady-state probabilities/rewards.*/
	private boolean uniformize;
	
	/** Requested total accuracy passed in from the parent prismComponent (termCritParam) */
	private BigDecimal epsilon;
	/** Default first stage accuracy for computing kappa */
	private static final BigDecimal pre_epsilon = BigDecimal.ONE;
	
	/**
	 * The only constructor
	 * @param actmc Associated ACTMC model. Must not be null!
	 * @param actmcRew Optional reward structure associated with {@code actmc}. May be null.
	 * @param uniformize If this is true, the resulting dtmc and rewards are uniformized so that
	 *  				 each step of the dtmc corresponds to the same real time unit,
	 *  				 precisely 1/dtmc.uniformizationRate.
	 *  				 Generally, this should be true for Total Reward/Reachability reward
	 *  				 kind of computations, and false for Steady-state probabilities/rewards.
	 * @param target Optional bitset of target states (if doing reachability). May be null.
	 * @param parent PrismComponent, presumably a model checker.
	 * Used to obtain current settings.
	 * @throws Exception if the arguments break the above rules
	 */
	public ACTMCReduction(ACTMCSimple actmc, ACTMCRewardsSimple actmcRew, boolean uniformize, BitSet target, PrismComponent parent) throws PrismException {
		super(parent);
		if (actmc == null) {
			throw new NullPointerException("ACTMCReduction constructor has received a null actmc!");
		}
		this.actmc = actmc;
		this.actmcRew = actmcRew;
		this.uniformize = uniformize;
		this.target = target;
		if (this.target == null) {
			this.target = new BitSet(actmc.getNumStates());
		}
		this.epsilon = new BigDecimal(this.getSettings().getDouble(PrismSettings.PRISM_TERM_CRIT_PARAM));
		this.pdMap = createPotatoDataMap(this.actmc, this.actmcRew, this.target);
		this.relevantStates = new BitSet(actmc.getNumStates());
		setRelevantStatesAndEntrances();
		
	}
	
	/**
	 * Get a DTMC fully equivalent to {@code actmc}.
	 * Computed DTMC is accurate up to error {@literal kappa} computed by this class.
	 */
	public DTMCSimple getDTMC() throws PrismException {
		if (dtmc == null) {
			computeEquivalentDTMC();
		}
		return dtmc;
	}
	
	/**
	 * Get a DTMC reward structure for {@code dtmc} fully equivalent to {@code actmc}.
	 * Computed values are accurate up to error {@literal kappa} computed by this class.
	 * @param divideByUniformizationRate is true if the computed rewards should be divided
	 * by the {@code dtmc} uniformization rate. Commonly, this should true when computing
	 * steady-state rewards, and false when computing reachability rewards.
	 */
	public MCRewards getDTMCRew() throws PrismException {
		if (dtmc == null) {
			computeEquivalentDTMC();
		}
		if (dtmcRew == null) {
			computeEquivalentDTMCRew();
		}
		return dtmcRew;
	}
	
	/**
	 * Get {@code ACTMCPotatoData} used to create equivalent DTMC.
	 * Computed values are accurate up to error {@literal kappa} computed by this class.
	 */
	public Map<String, ACTMCPotatoData> getPotatoData() throws PrismException {
		if (dtmc == null) {
			computeEquivalentDTMC();
		}
		return pdMap;
	}
	
	private void computeEquivalentDTMC() throws PrismException {
		setKappa(computeKappa());
		if (uniformize) {
			dtmc = constructUniformizedDTMC();
		} else {
			dtmc = constructDTMC();
		}
	}
	
	private void computeEquivalentDTMCRew() throws PrismException {
		if (dtmc == null) {
			computeEquivalentDTMC();
		}
		if (uniformize) {
			dtmcRew = constructUniformizedDTMCRew(dtmc);
		} else {
			dtmcRew = constructDTMCRew(dtmc);
		}
	}
	
	/**
	 * Computes and sets the bitset of relevant states, and the set of entrances.
	 * The {@code pdMap} must already be correctly initialised!
	 */
	private void setRelevantStatesAndEntrances() {
		Set<Integer> potatoStates = new HashSet<Integer>();
		Set<Integer> entranceStates = new HashSet<Integer>();
		for (Map.Entry<String, ACTMCPotatoData> pdEntry : pdMap.entrySet()) {
			potatoStates.addAll(pdEntry.getValue().getPotato());
			entranceStates.addAll(pdEntry.getValue().getEntrances());
		}
		
		relevantStates.set(0, actmc.getNumStates());
		for (int ps : potatoStates) {
			relevantStates.set(ps, false);
		}
		for (int es : entranceStates) {
			relevantStates.set(es, true);
		}
	}
	
	/**
	 * Assigns {@code kappa} to all ACTMCPotatoData within {@code pdMap}.
	 * <br>
	 * I.e. next ACTMCPotatoData computations will be with precision kappa.
	 * @param kappa BigDecimal allowed error bound
	 */
	private void setKappa(BigDecimal kappa) {
		for (Map.Entry<String, ACTMCPotatoData> pdEntry : pdMap.entrySet()) {
			pdEntry.getValue().setKappa(kappa);
		}
	}
	
	/**
	 * Computes the kappa error bound such that any model checking
	 * done on a thusly created {@code dtmc} is guaranteed to be accurate
	 * within allowed error {@code epsilon}.
	 */
	private BigDecimal computeKappa() throws PrismException {
		MathContext mc;
		BigDecimal n = new BigDecimal(actmc.getNumStates() - target.cardinality()); // amount of non-target states
		
		// derive kappaOne and kappaTwo from a rough estimate of the model structure
		BigDecimal kappaOne;
		BigDecimal kappaTwo; {
			Pair<Double, Double> minProb_maxRew = compute_minProb_maxRew();
			double minProb = minProb_maxRew.getKey();
			double maxRew = 0;
			if (actmcRew != null) {
				maxRew = minProb_maxRew.getValue();
			}
			if (maxRew == 0) { // This deals with situations where there are no rewards.
				maxRew = 1;
			}
			BigDecimal baseKappaOne = new BigDecimal(minProb / 2);
			BigDecimal baseKappaTwo = new BigDecimal(Math.min(baseKappaOne.doubleValue(), maxRew));
			BigDecimal maxExpectedSteps; {
				int maxExpectedStepsScale = 1 + baseKappaOne.scale() * n.intValue();
				mc = new MathContext(maxExpectedStepsScale + 2, RoundingMode.HALF_UP);
				maxExpectedSteps = n.divide(BigDecimalMath.pow(baseKappaOne, n, mc), mc);
			}
			BigDecimal maxExpectedTR = maxExpectedSteps.multiply(new BigDecimal(maxRew));
			BigDecimal b = BigDecimal.ONE.divide(new BigDecimal("2.0").multiply(maxExpectedSteps).multiply(n), mc);
			/* kappaOne derivation*/ {
				BigDecimal c = pre_epsilon.divide(new BigDecimal("2.0").multiply(maxExpectedSteps).multiply(maxExpectedSteps.multiply(n).add(BigDecimal.ONE)), mc);
				kappaOne = BigDecimalUtils.min(baseKappaOne, BigDecimalUtils.min(b, c));
			}
			/* kappaTwo derivation*/ {
				BigDecimal c = pre_epsilon.divide(new BigDecimal("2.0").multiply(maxExpectedSteps).multiply(maxExpectedTR.multiply(n).add(BigDecimal.ONE)), mc);
				kappaTwo = BigDecimalUtils.min(baseKappaTwo, BigDecimalUtils.min(b, c));
			}
		}

		// derive a more precise estimate of the upper bound on the amount of steps
		BigDecimal maxSteps = new BigDecimal(Double.MIN_VALUE); {
			setKappa(kappaOne);
			DTMCSimple kappaOneDTMC = constructUniformizedDTMC();
			MCRewards kappaOneDTMCRew = new StateRewardsConstant(1);
			DTMCModelChecker mc1 = new DTMCModelChecker(this);
			mc1.termCritParam = pre_epsilon.doubleValue();
			mc1.linEqMethod = LinEqMethod.GAUSS_SEIDEL; // TODO MAJO - maybe this can go away, but reliability is priority!
			mc1.maxIters = 250000;
			mc1.setLog(new PrismDevNullLog()); // mute the reachability computation log messages
			for (int s = relevantStates.nextSetBit(0); s >= 0; s = relevantStates.nextSetBit(s+1)) {
				boolean isEntranceTarget = target.get(s);
				target.set(s);
				ModelCheckerResult kappaOneTR = mc1.computeReachRewards(kappaOneDTMC, kappaOneDTMCRew, target);
				target.set(s, isEntranceTarget);
				
				BigDecimal max = (new BigDecimal(findMaxTR(kappaOneTR.soln))).add(pre_epsilon);
				if (maxSteps.compareTo(max) < 0) {
					maxSteps = max;
				}
			}
		}
		
		// derive a more precise estimate of the upper bound on the total reward
		BigDecimal maxTR = new BigDecimal(Double.MIN_VALUE); {
			setKappa(kappaTwo);
			DTMCSimple kappaTwoDTMC = constructUniformizedDTMC();
			MCRewards kappaTwoDTMCRew = constructUniformizedDTMCRew(kappaTwoDTMC);
			DTMCModelChecker mc2 = new DTMCModelChecker(this);
			mc2.termCritParam = pre_epsilon.doubleValue();
			mc2.linEqMethod = LinEqMethod.GAUSS_SEIDEL; // TODO MAJO - maybe this can go away, but reliability is priority!
			mc2.maxIters = 250000;
			mc2.setLog(new PrismDevNullLog()); // mute the reachability computation log messages
			for (int s = relevantStates.nextSetBit(0); s >= 0; s = relevantStates.nextSetBit(s+1)) {
				boolean isEntranceTarget = target.get(s);
				target.set(s);
				ModelCheckerResult kappaTwoTR = mc2.computeReachRewards(kappaTwoDTMC, kappaTwoDTMCRew, target);
				target.set(s, isEntranceTarget);
				
				BigDecimal max = (new BigDecimal(findMaxTR(kappaTwoTR.soln))).add(pre_epsilon);
				if (maxTR.compareTo(max) < 0) {
					maxTR = max;
				}
			}
		}
		
		// use the previous values to derive the actual kappa allowed error bound
		BigDecimal kappa; {
		BigDecimal aAccurate = BigDecimal.ONE.divide(new BigDecimal("2.0").multiply(n).multiply(maxSteps), mc);
		BigDecimal bAccurate = epsilon.divide(new BigDecimal("2.0").multiply(maxSteps).multiply(maxTR.multiply(n).add(BigDecimal.ONE)), mc);
		
		kappa = BigDecimalUtils.min(kappaOne, BigDecimalUtils.min(kappaTwo, BigDecimalUtils.min(aAccurate, bAccurate)));
		}
		
		return kappa;
	}
	
	/**
	 * Computes the lowest probability that could be present within a {@code dtmc}
	 * created from {@code actmc} and the highest reward that could be present
	 * within an equivalent reward structure for {@code dtmc}.
	 * @return a pair where the key is the minimum probability, and the value is the maximum reward
	 */
	private Pair<Double, Double> compute_minProb_maxRew() throws PrismException {
		final double kappa = 1.0e-5;
		final BigDecimal kappaBD = new BigDecimal(kappa);
		setKappa(kappaBD);
		
		// construct dtmc and dtmcRew
		DTMCSimple dtmc = constructDTMC();
		StateRewardsSimple rewards = constructDTMCRew(dtmc);
		
		// obtain the values and adjust them for potential kappa error
		BitSet relevantStates = new BitSet(actmc.getNumStates());
		relevantStates.or(this.relevantStates);
		relevantStates.andNot(target);
		double minProb = dtmc.getMinimumProbability(relevantStates) + kappa;
		double maxRew = rewards.getMax(relevantStates) + kappa; 
		
		return new Pair<Double, Double>(minProb, maxRew);
	}
	
	/**
	 * Finds the maximum element of the array, but only considers {@code relevantStates}.
	 * @return If relevant results are given, returns their maximum. <br>
	 * 		   If the maximum of the relevant results is {@literal Infinity}, returns 1. <br>
	 * 		   If the maximum of the relevant results is 0, throws an exception. <br>
	 * 		   If no relevant results are given, returns 1. <br>
	 * 
	 */
	private double findMaxTR(double[] soln) throws PrismException {
		
		// find maximum of the relevant states
		double max = Double.MIN_VALUE;
		for (int s = relevantStates.nextSetBit(0); s >= 0; s = relevantStates.nextSetBit(s+1)) {
			if (soln[s] > max) {
				max = soln[s];
			}
		}
		
		if (Double.isInfinite(max)) {
			max = 1; 
			// This deals with strange behavior of reachability rewards when entrance is the initial state.
		}
		if (max == Double.MIN_VALUE) {
			max = 1; 
			// This deals with strange behavior of reachability rewards when there are no rewards.
		}
		if (max == 0) {
			throw new PrismException("ACTMC reduction to DTMC failed: maximum Reachability Reward is 0!");
			// This should never happen.
		}
		
		return max;
	}
	
	/**
	 * Uses {@code actmc} and current {@code pdMap} to construct
	 * an equivalent {@code dtmc}.
	 * This is suitable for steady-state probabilities/rewards.
	 * @return {@code dtmc} equivalent to {@code actmc} according to the current {@code pdMap}
	 */
	private DTMCSimple constructDTMC() throws PrismException {
		CTMCSimple ctmc = new CTMCSimple(actmc);
		double uniformizationRate = ctmc.getMaxExitRate();
		DTMCSimple dtmc = ctmc.buildUniformisedDTMC(uniformizationRate);
		
		for (Map.Entry<String, ACTMCPotatoData> pdEntry : pdMap.entrySet()) {
			ACTMCPotatoData potatoData = pdEntry.getValue();
			Map<Integer, Distribution> meanDistrs = potatoData.getMeanDistributions();
			
			Set<Integer> potatoEntrances = potatoData.getEntrances();
			for (int entrance : potatoEntrances) {
				// assign the computed distribution the CTMC
				Distribution meanDistr = new Distribution(meanDistrs.get(entrance));
				Set<Integer> distrSupport = meanDistrs.get(entrance).getSupport();
				for ( int s : distrSupport) {
					meanDistr.set(s, meanDistr.get(s));
				}
				dtmc.trans.set(entrance, meanDistr);
			}
		}
		
		return dtmc;
	}
	
	/**
	 * Uses {@code actmc} and current {@code pdMap} to construct
	 * equivalent uniformized {@code dtmc}. The DTMC is uniformized in accordance to how much
	 * time is spent within each potato having entered from a particular entrance.
	 * This is suitable for reachability rewards.
	 * @return Uniformized {@code dtmc} equivalent to {@code actmc} according to the current {@code pdMap}
	 */
	private DTMCSimple constructUniformizedDTMC() throws PrismException {
		CTMCSimple ctmc = new CTMCSimple(actmc);
		double uniformizationRate = ctmc.getMaxExitRate();
		
		for (Map.Entry<String, ACTMCPotatoData> pdEntry : pdMap.entrySet()) {
			ACTMCPotatoData potatoData = pdEntry.getValue();
			Map<Integer, Distribution> meanTimesWithinPotato = potatoData.getMeanTimes();
			Map<Integer, Distribution> meanDistrs = potatoData.getMeanDistributions();
			
			Set<Integer> potatoEntrances = potatoData.getEntrances();
			for (int entrance : potatoEntrances) {
				// compute the rate
				Distribution potatoTimeDistr = meanTimesWithinPotato.get(entrance);
				double theta = potatoTimeDistr.sum();
				double meanRateWithinPotato = 1 / theta;
				if ((meanRateWithinPotato) > uniformizationRate) {
					uniformizationRate = meanRateWithinPotato;
				}
				
				// weigh the distribution by the rate and assign it to the CTMC
				Distribution meanDistr = new Distribution(meanDistrs.get(entrance));
				Set<Integer> distrSupport = meanDistrs.get(entrance).getSupport();
				for ( int s : distrSupport) {
					meanDistr.set(s, meanDistr.get(s) * meanRateWithinPotato);
				}
				ctmc.trans.set(entrance, meanDistr);
			}
		}
		
		// Then, reduce the CTMC to a DTMC.
		DTMCSimple dtmc = ctmc.buildUniformisedDTMC(uniformizationRate);
		return dtmc;
	}
	
	/**
	 * Uses {@code actmc}, {@code actmcRew} and current {@code pdMap} to construct
	 * equivalent {@code mcRewards} for {@code dtmc}.
	 * This is suitable for steady-state rewards.
	 * <br>
	 * Iff {@code divideByUniformizationRate} is true,
	 * rewards are also adjusted to {@code dtmc.uniformizationRate}.
	 * @return {@code MCRewards} equivalent to actmcRew
	 */
	private StateRewardsSimple constructDTMCRew(DTMCSimple dtmc) throws PrismException {
		StateRewardsSimple newRew = new StateRewardsSimple();
		if (actmcRew == null) {
			return newRew;
		}
		
		for (int s = 0; s < dtmc.getNumStates() ; ++s) {
			double rew = actmcRew.getStateReward(s);
			if (rew > 0) {
				newRew.setStateReward(s, rew);
			}
		}
		
		for (Map.Entry<String, ACTMCPotatoData> pdEntry : pdMap.entrySet()) {
			ACTMCPotatoData potatoData = pdEntry.getValue();
			Set<Integer> entrances = potatoData.getEntrances();
			for (int entrance : entrances) {
				double rew = potatoData.getMeanRewards().get(entrance);
				newRew.setStateReward(entrance, rew);
			}
		}
		
		return newRew;
	}
	
	/**
	 * Uses {@code actmc}, {@code actmcRew} and current {@code pdMap} to construct
	 * equivalent {@code mcRewards} for uniformized {@code dtmc} (created by {@code constructUniformizedDTMC()},
	 * i.e. the rewards are weighted in accordance to how much time is spent within potatoes.
	 * This is suitable for reachability rewards.
	 * <br>
	 * Iff {@code divideByUniformizationRate} is true,
	 * rewards are also adjusted to {@code dtmc.uniformizationRate}.
	 * @return Uniformized {@code MCRewards} equivalent to actmcRew
	 */
	private StateRewardsSimple constructUniformizedDTMCRew(DTMCSimple dtmc) throws PrismException {
		StateRewardsSimple newRew = new StateRewardsSimple();
		if (actmcRew == null) {
			return newRew;
		}
		
		int numStates = dtmc.getNumStates();
		for (int s = 0; s < numStates ; ++s) {
			double rew = actmcRew.getStateReward(s);
			if (rew > 0) {
				newRew.setStateReward(s, rew / dtmc.uniformizationRate);
			}
		}
		
		for (Map.Entry<String, ACTMCPotatoData> pdEntry : pdMap.entrySet()) {
			ACTMCPotatoData potatoData = pdEntry.getValue();
			Set<Integer> entrances = potatoData.getEntrances();
			for (int entrance : entrances) {
				double rew = potatoData.getMeanRewards().get(entrance);
				if (rew > 0) {
					double theta = potatoData.getMeanTimes().get(entrance).sum();
					double meanRew = rew / theta;//average reward over average time spent within
					newRew.setStateReward(entrance, meanRew / dtmc.uniformizationRate);
				}
			}
		}
		
		return newRew;
	}

	/**
	 * Creates a map where the keys are string identifiers of the GSMPEvents,
	 * and the values are corresponding ACTMCPotatoData structures.
	 * This is useful as to enable reusage of the ACTMCPotatoData structures efficiently.
	 * @param actmc ACTMC model for which to create the ACTMCPotatoData structures
	 * @param rew Optional rewards associated with {@code actmc}. May be null, but calls
	 *            to {@code ACTMCPotatoData.getMeanReward()} will throw an exception!
	 */
	private Map<String, ACTMCPotatoData> createPotatoDataMap(ACTMCSimple actmc,
			ACTMCRewardsSimple rew, BitSet target) throws PrismException {
		Map<String, ACTMCPotatoData> pdMap = new HashMap<String, ACTMCPotatoData>();
		List<GSMPEvent> events = actmc.getEventList();
		
		for (GSMPEvent event: events) {
			ACTMCPotatoData potatoData = new ACTMCPotatoData(actmc,
					event,
					rew,
					target);
			pdMap.put(event.getIdentifier(), potatoData);
		}
		return pdMap;
	}
	
}