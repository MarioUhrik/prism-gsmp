//==============================================================================
//	
//	Copyright (c) 2018-
//	Authors:
//	* Mario Uhrik <433501@mail.muni.cz> (Masaryk University)
//	
//------------------------------------------------------------------------------
//	
//	This file is part of PRISM.
//	
//	PRISM is free software; you can redistribute it and/or modify
//	it under the terms of the GNU General Public License as published by
//	the Free Software Foundation; either version 2 of the License, or
//	(at your option) any later version.
//	
//	PRISM is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//	GNU General Public License for more details.
//	
//	You should have received a copy of the GNU General Public License
//	along with PRISM; if not, write to the Free Software Foundation,
//	Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//	
//==============================================================================

package explicit;

import java.math.BigDecimal;
import java.math.MathContext;
import java.math.RoundingMode;
import java.util.BitSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Vector;

import org.nevec.rjm.BigDecimalMath;

import common.BigDecimalUtils;
import explicit.ProbModelChecker.LinEqMethod;
import explicit.rewards.ACTMCRewardsSimple;
import explicit.rewards.MCRewards;
import explicit.rewards.StateRewardsConstant;
import explicit.rewards.StateRewardsSimple;
import prism.PrismComponent;
import prism.PrismDevNullLog;
import prism.PrismException;
import prism.PrismSettings;

/**
 * Class for reduction of ACTMC to equivalent DTMC. (and also their reward structures)
 * <br>
 * This class fulfills similar purpose to class {@code ACTMCPotatoData},
 * but on the scope of the entire ACTMC, whereas the scope of {@code ACTMCPotatoData}
 * only encompasses a single event.
 */
public class ACTMCReduction extends PrismComponent // TODO MAJO - optimize!
{
	/** ACTMC model this class is associated with */
	private ACTMCSimple actmc;
	/** Optional reward structure associated with {@code actmc}.
	 *  The CTMC transition rewards are already expected to have been converted to state rewards.
	 *  May be null if rewards are not of interest for given model checking method.*/
	private ACTMCRewardsSimple actmcRew = null;
	/** Optional bitset of target states (for reachability) */
	private BitSet target = null;
	/** Map where the keys are string identifiers of the GSMPEvents,
	 *  and the values are corresponding ACTMCPotatoData structures.
	 *  This is useful for fast access and efficient reusage of the ACTMCPotatoData structures.*/
	private Map<String, ACTMCPotatoData> pdMap;
	/** DTMC equivalent to {@code actmc} eventually generated by this class.
	 *  Initially null.*/
	private DTMCSimple dtmc = null;
	private MCRewards dtmcRew = null;
	/** If this is true, the resulting dtmc and rewards are uniformized so that
	 *  each step of the dtmc corresponds to the same real time unit,
	 *  precisely 1/dtmc.uniformizationRate.
	 *  Generally, this should be true for Total Reward/Reachability reward
	 *  kind of computations, and false for Steady-state probabilities/rewards.*/
	private boolean uniformize;
	
	/** Requested total accuracy passed in from the parent prismComponent (termCritParam) */
	private BigDecimal epsilon;
	/** Default first stage accuracy for computing kappa */
	private static final BigDecimal pre_epsilon = BigDecimal.ONE;
	
	/**
	 * The only constructor
	 * @param actmc Associated ACTMC model. Must not be null!
	 * @param actmcRew Optional reward structure associated with {@code actmc}. May be null.
	 * @param uniformize If this is true, the resulting dtmc and rewards are uniformized so that
	 *  				 each step of the dtmc corresponds to the same real time unit,
	 *  				 precisely 1/dtmc.uniformizationRate.
	 *  				 Generally, this should be true for Total Reward/Reachability reward
	 *  				 kind of computations, and false for Steady-state probabilities/rewards.
	 * @param target Optional bitset of target states (if doing reachability). May be null.
	 * @param parent PrismComponent, presumably a model checker.
	 * Used to obtain current settings.
	 * @throws Exception if the arguments break the above rules
	 */
	public ACTMCReduction(ACTMCSimple actmc, ACTMCRewardsSimple actmcRew, boolean uniformize, BitSet target, PrismComponent parent) throws PrismException {
		super(parent);
		if (actmc == null) {
			throw new NullPointerException("ACTMCReduction constructor has received a null actmc!");
		}
		this.actmc = actmc;
		this.actmcRew = actmcRew;
		this.uniformize = uniformize;
		this.target = target;
		if (this.target == null) {
			this.target = new BitSet(actmc.getNumStates());
		}
		this.epsilon = new BigDecimal(this.getSettings().getDouble(PrismSettings.PRISM_TERM_CRIT_PARAM));
		this.pdMap = createPotatoDataMap(this.actmc, this.actmcRew, this.target);
	}
	
	/**
	 * Get a DTMC fully equivalent to {@code actmc}.
	 * Computed DTMC is accurate up to error {@literal kappa} computed by this class.
	 */
	public DTMCSimple getDTMC() throws PrismException {
		if (dtmc == null) {
			computeEquivalentDTMC();
		}
		return dtmc;
	}
	
	/**
	 * Get a DTMC reward structure for {@code dtmc} fully equivalent to {@code actmc}.
	 * Computed values are accurate up to error {@literal kappa} computed by this class.
	 * @param divideByUniformizationRate is true if the computed rewards should be divided
	 * by the {@code dtmc} uniformization rate. Commonly, this should true when computing
	 * steady-state rewards, and false when computing reachability rewards.
	 */
	public MCRewards getDTMCRew() throws PrismException {
		if (dtmc == null) {
			computeEquivalentDTMC();
		}
		if (dtmcRew == null) {
			computeEquivalentDTMCRew();
		}
		return dtmcRew;
	}
	
	/**
	 * Get {@code ACTMCPotatoData} used to create equivalent DTMC.
	 * Computed values are accurate up to error {@literal kappa} computed by this class.
	 */
	public Map<String, ACTMCPotatoData> getPotatoData() throws PrismException {
		if (dtmc == null) {
			computeEquivalentDTMC();
		}
		return pdMap;
	}
	
	private void computeEquivalentDTMC() throws PrismException {
		computeKappa();
		if (uniformize) {
			dtmc = constructUniformizedDTMC();
		} else {
			dtmc = constructDTMC();
		}
	}
	
	private void computeEquivalentDTMCRew() throws PrismException {
		if (dtmc == null) {
			computeEquivalentDTMC();
		}
		if (uniformize) {
			dtmcRew = constructUniformizedDTMCRew(dtmc);
		} else {
			dtmcRew = constructDTMCRew(dtmc);
		}
	}
	
	/**
	 * Computes the kappa error bounds and assigns it to the {@code pdMap}.
	 */
	private Map<Integer, BigDecimal> computeKappa() throws PrismException {
		Map<Integer, MathContext> mcMap = new HashMap<Integer, MathContext>();
		MathContext mc;
		Map<Integer, BigDecimal> kappaOneMap = new HashMap<Integer, BigDecimal>();
		Map<Integer, BigDecimal> kappaTwoMap = new HashMap<Integer, BigDecimal>();
		Map<Integer, BigDecimal> maxStepsMap = new HashMap<Integer, BigDecimal>();
		Map<Integer, BigDecimal> maxTRMap = new HashMap<Integer, BigDecimal>();
		Map<Integer, BigDecimal> nMap = new HashMap<Integer, BigDecimal>(); // actually integers
		Set<Integer> allEntrances = new HashSet<Integer>();
		
		for (Map.Entry<String, ACTMCPotatoData> pdEntry : pdMap.entrySet()) {
			ACTMCPotatoData pd = pdEntry.getValue();
			Set<Integer> entrances = pd.getEntrances();
			allEntrances.addAll(entrances);
			DTMCSimple potatoDTMC = pd.getPotatoDTMC();
			Map<Integer, Integer> ACTMCtoDTMC = pd.getMapACTMCtoDTMC();
			Vector<Integer> DTMCtoACTMC = pd.getMapDTMCtoACTMC();
			
			BitSet targetPermut = new BitSet(actmc.getNumStates());
			for (int i = target.nextSetBit(0); i >= 0; i = target.nextSetBit(i+1)) {
				Integer permutTarget = ACTMCtoDTMC.get(i);
				if (permutTarget != null) {
					targetPermut.set(ACTMCtoDTMC.get(i));
				}
			}
			
			for (int entrance : entrances) {
				BitSet reachableStatesPermut = potatoDTMC.getReachableStates(ACTMCtoDTMC.get(entrance), targetPermut);
				// TODO MAJO - Optimize by doing them per entire bitset!
				BitSet reachableStates = new BitSet(actmc.getNumStates());
				for (int i = reachableStatesPermut.nextSetBit(0); i >= 0; i = reachableStatesPermut.nextSetBit(i+1)) {
					reachableStates.set(DTMCtoACTMC.get(i));
				}
				
				double minProb = potatoDTMC.getMinimumProbability(reachableStatesPermut);
				double maxRew = 0;
				if (actmcRew != null) {
					maxRew = actmcRew.getMax(reachableStates);
				}
				if (maxRew == 0) { // This deals with situations where there are no rewards.
					maxRew = 1;
				}
				BigDecimal baseKappaOne = new BigDecimal(minProb / 2);
				BigDecimal baseKappaTwo = new BigDecimal(Math.min(baseKappaOne.doubleValue(), maxRew));
				BigDecimal n = new BigDecimal(reachableStates.cardinality()); // amount of non-target states
				nMap.put(entrance, n);
				BigDecimal maxExpectedSteps; {
					int maxExpectedStepsScale = 1 + baseKappaOne.scale() * n.intValue();
					mc = new MathContext(maxExpectedStepsScale + 2, RoundingMode.HALF_UP);
					mcMap.put(entrance, mc);
					
					n = n.setScale(n.intValue(), RoundingMode.HALF_UP);
					maxExpectedSteps = n.divide(BigDecimalMath.pow(baseKappaOne, n), mc);
				}
				BigDecimal maxExpectedTR = maxExpectedSteps.multiply(new BigDecimal(maxRew));
				BigDecimal b = BigDecimal.ONE.divide(new BigDecimal("2.0").multiply(maxExpectedSteps).multiply(n), mc);
				BigDecimal kappaOne; {
					BigDecimal c = pre_epsilon.divide(new BigDecimal("2.0").multiply(maxExpectedSteps).multiply(maxExpectedSteps.multiply(n).add(BigDecimal.ONE)), mc);
					kappaOne = BigDecimalUtils.min(baseKappaOne, BigDecimalUtils.min(b, c));
					kappaOne.setScale(mc.getPrecision(), RoundingMode.HALF_UP);
				}
				BigDecimal kappaTwo; {
					BigDecimal c = pre_epsilon.divide(new BigDecimal("2.0").multiply(maxExpectedSteps).multiply(maxExpectedTR.multiply(n).add(BigDecimal.ONE)), mc);
					kappaTwo = BigDecimalUtils.min(baseKappaTwo, BigDecimalUtils.min(b, c));
					kappaTwo.setScale(mc.getPrecision(), RoundingMode.HALF_UP);
				}
				kappaOneMap.put(entrance, kappaOne);
				kappaTwoMap.put(entrance, kappaTwo);
			}
			pd.setKappaMap(kappaOneMap);
		}

		DTMCSimple kappaOneDTMC = constructUniformizedDTMC();
		MCRewards kappaOneDTMCRew = new StateRewardsConstant(1);
		DTMCModelChecker mc1 = new DTMCModelChecker(this);
		mc1.termCritParam = pre_epsilon.doubleValue();
		mc1.linEqMethod = LinEqMethod.GAUSS_SEIDEL; // TODO MAJO - maybe this can go away, but reliability is priority!
		mc1.maxIters = 250000;
		mc1.setLog(new PrismDevNullLog()); // mute the reachability computation log messages
		for (int entrance : allEntrances ) {
			boolean isEntranceTarget = target.get(entrance);
			target.set(entrance);
			ModelCheckerResult kappaOneTR = mc1.computeReachRewards(kappaOneDTMC, kappaOneDTMCRew, target);
			target.set(entrance, isEntranceTarget);
			
			BigDecimal max = new BigDecimal(findMaxTR(kappaOneTR.soln));
			maxStepsMap.put(entrance, max.add(pre_epsilon));
		}
		
		for (Map.Entry<String, ACTMCPotatoData> pdEntry : pdMap.entrySet()) {
			pdEntry.getValue().setKappaMap(kappaTwoMap);
		}
		DTMCSimple kappaTwoDTMC = constructUniformizedDTMC();
		MCRewards kappaTwoDTMCRew = constructUniformizedDTMCRew(kappaTwoDTMC);
		DTMCModelChecker mc2 = new DTMCModelChecker(this);
		mc2.termCritParam = pre_epsilon.doubleValue();
		mc2.linEqMethod = LinEqMethod.GAUSS_SEIDEL; // TODO MAJO - maybe this can go away, but reliability is priority!
		mc2.maxIters = 250000;
		mc2.setLog(new PrismDevNullLog()); // mute the reachability computation log messages
		for (int entrance : allEntrances ) {
			boolean isEntranceTarget = target.get(entrance);
			target.set(entrance);
			ModelCheckerResult kappaTwoTR = mc2.computeReachRewards(kappaTwoDTMC, kappaTwoDTMCRew, target);
			target.set(entrance, isEntranceTarget);
			
			BigDecimal max = new BigDecimal(findMaxTR(kappaTwoTR.soln));
			maxTRMap.put(entrance, max.add(pre_epsilon));
		}
		
		Map<Integer, BigDecimal> kappaMap = new HashMap<Integer, BigDecimal>();
		for (Map.Entry<Integer, BigDecimal> entry : kappaOneMap.entrySet()) {
			int entrance = entry.getKey();
			BigDecimal kappaOne = entry.getValue();
			BigDecimal kappaTwo = kappaTwoMap.get(entrance);
			BigDecimal maxSteps = maxStepsMap.get(entrance);
			BigDecimal maxTR = maxTRMap.get(entrance);
			BigDecimal n = nMap.get(entrance);
			mc = mcMap.get(entrance);
			
			BigDecimal a = BigDecimal.ONE.divide(new BigDecimal("2.0").multiply(n).multiply(maxSteps), mc);
			BigDecimal b = epsilon.divide(new BigDecimal("2.0").multiply(maxSteps).multiply(maxTR.multiply(n).add(BigDecimal.ONE)), mc);
			
			BigDecimal kappa = BigDecimalUtils.min(kappaOne, BigDecimalUtils.min(kappaTwo, BigDecimalUtils.min(a, b)));
			kappa.setScale(mc.getPrecision(), RoundingMode.HALF_UP);
			kappaMap.put(entrance, kappa);
		}
		
		for (Map.Entry<String, ACTMCPotatoData> pdEntry : pdMap.entrySet()) {
			pdEntry.getValue().setKappaMap(kappaMap);
		}
		
		return kappaMap;
	}
	
	/**
	 * Finds the maximum element of the array, but only considers indices
	 * that are either potato entrances or outside the potato.
	 * @return If relevant results are given, returns their maximum. <br>
	 * 		   If the maximum of the relevant results is {@literal Infinity}, returns 1. <br>
	 * 		   If the maximum of the relevant results is 0, throws an exception. <br>
	 * 		   If no relevant results are given, returns 1. <br>
	 * 
	 */
	private double findMaxTR(double[] soln) throws PrismException {
		// find relevant states
		Set<Integer> potatoes = new HashSet<Integer>();
		Set<Integer> entrances = new HashSet<Integer>();
		for (Map.Entry<String, ACTMCPotatoData> pdEntry : pdMap.entrySet()) {
			entrances.addAll(pdEntry.getValue().getEntrances());
			potatoes.addAll(pdEntry.getValue().getPotato());
		}
		Set<Integer> relevantStates = new HashSet<Integer>();
		for (int i = 0; i < actmc.getNumStates() ; ++i) {
			relevantStates.add(i);
		}
		relevantStates.removeAll(potatoes);
		relevantStates.addAll(entrances);
		
		// find maximum of the relevant states
		double max = Double.MIN_VALUE;
		for (int relevantState : relevantStates) {
			if (soln[relevantState] > max) {
				max = soln[relevantState];
			}
		}
		if (Double.isInfinite(max)) {
			max = 1; 
			// This deals with strange behavior of reachability rewards when entrance is the initial state.
		}
		if (max == Double.MIN_VALUE) {
			max = 1; 
			// This deals with strange behavior of reachability rewards when there are no rewards.
		}
		if (max == 0) {
			throw new PrismException("ACTMC reduction to DTMC failed: maximum Reachability Reward is 0!");
			// This should never happen.
		}
		
		return max;
	}
	
	/**
	 * Uses {@code actmc} and current {@code pdMap} to construct
	 * an equivalent {@code dtmc}.
	 * This is suitable for steady-state probabilities/rewards.
	 * @return {@code dtmc} equivalent to {@code actmc} according to the current {@code pdMap}
	 */
	private DTMCSimple constructDTMC() throws PrismException {
		CTMCSimple ctmc = new CTMCSimple(actmc);
		double uniformizationRate = ctmc.getMaxExitRate();
		DTMCSimple dtmc = ctmc.buildUniformisedDTMC(uniformizationRate);
		
		for (Map.Entry<String, ACTMCPotatoData> pdEntry : pdMap.entrySet()) {
			ACTMCPotatoData potatoData = pdEntry.getValue();
			Map<Integer, Distribution> meanDistrs = potatoData.getMeanDistributions();
			
			Set<Integer> potatoEntrances = potatoData.getEntrances();
			for (int entrance : potatoEntrances) {
				// assign the computed distribution the CTMC
				Distribution meanDistr = new Distribution(meanDistrs.get(entrance));
				Set<Integer> distrSupport = meanDistrs.get(entrance).getSupport();
				for ( int s : distrSupport) {
					meanDistr.set(s, meanDistr.get(s));
				}
				dtmc.trans.set(entrance, meanDistr);
			}
		}
		
		return dtmc;
	}
	
	/**
	 * Uses {@code actmc} and current {@code pdMap} to construct
	 * equivalent uniformized {@code dtmc}. The DTMC is uniformized in accordance to how much
	 * time is spent within each potato having entered from a particular entrance.
	 * This is suitable for reachability rewards.
	 * @return Uniformized {@code dtmc} equivalent to {@code actmc} according to the current {@code pdMap}
	 */
	private DTMCSimple constructUniformizedDTMC() throws PrismException {
		CTMCSimple ctmc = new CTMCSimple(actmc);
		double uniformizationRate = ctmc.getMaxExitRate();
		
		for (Map.Entry<String, ACTMCPotatoData> pdEntry : pdMap.entrySet()) {
			ACTMCPotatoData potatoData = pdEntry.getValue();
			Map<Integer, Distribution> meanTimesWithinPotato = potatoData.getMeanTimes();
			Map<Integer, Distribution> meanDistrs = potatoData.getMeanDistributions();
			
			Set<Integer> potatoEntrances = potatoData.getEntrances();
			for (int entrance : potatoEntrances) {
				// compute the rate
				Distribution potatoTimeDistr = meanTimesWithinPotato.get(entrance);
				double theta = potatoTimeDistr.sum();
				double meanRateWithinPotato = 1 / theta;
				if ((meanRateWithinPotato) > uniformizationRate) {
					uniformizationRate = meanRateWithinPotato;
				}
				
				// weigh the distribution by the rate and assign it to the CTMC
				Distribution meanDistr = new Distribution(meanDistrs.get(entrance));
				Set<Integer> distrSupport = meanDistrs.get(entrance).getSupport();
				for ( int s : distrSupport) {
					meanDistr.set(s, meanDistr.get(s) * meanRateWithinPotato);
				}
				ctmc.trans.set(entrance, meanDistr);
			}
		}
		
		// Then, reduce the CTMC to a DTMC.
		DTMCSimple dtmc = ctmc.buildUniformisedDTMC(uniformizationRate);
		return dtmc;
	}
	
	/**
	 * Uses {@code actmc}, {@code actmcRew} and current {@code pdMap} to construct
	 * equivalent {@code mcRewards} for {@code dtmc}.
	 * This is suitable for steady-state rewards.
	 * <br>
	 * Iff {@code divideByUniformizationRate} is true,
	 * rewards are also adjusted to {@code dtmc.uniformizationRate}.
	 * @return {@code MCRewards} equivalent to actmcRew
	 */
	private MCRewards constructDTMCRew(DTMCSimple dtmc) throws PrismException {
		StateRewardsSimple newRew = new StateRewardsSimple();
		if (actmcRew == null) {
			return newRew;
		}
		
		for (int s = 0; s < dtmc.getNumStates() ; ++s) {
			double rew = actmcRew.getStateReward(s);
			if (rew > 0) {
				newRew.setStateReward(s, rew);
			}
		}
		
		for (Map.Entry<String, ACTMCPotatoData> pdEntry : pdMap.entrySet()) {
			ACTMCPotatoData potatoData = pdEntry.getValue();
			Set<Integer> entrances = potatoData.getEntrances();
			for (int entrance : entrances) {
				double rew = potatoData.getMeanRewards().get(entrance);
				newRew.setStateReward(entrance, rew);
			}
		}
		
		return newRew;
	}
	
	/**
	 * Uses {@code actmc}, {@code actmcRew} and current {@code pdMap} to construct
	 * equivalent {@code mcRewards} for uniformized {@code dtmc} (created by {@code constructUniformizedDTMC()},
	 * i.e. the rewards are weighted in accordance to how much time is spent within potatoes.
	 * This is suitable for reachability rewards.
	 * <br>
	 * Iff {@code divideByUniformizationRate} is true,
	 * rewards are also adjusted to {@code dtmc.uniformizationRate}.
	 * @return Uniformized {@code MCRewards} equivalent to actmcRew
	 */
	private MCRewards constructUniformizedDTMCRew(DTMCSimple dtmc) throws PrismException {
		StateRewardsSimple newRew = new StateRewardsSimple();
		if (actmcRew == null) {
			return newRew;
		}
		
		int numStates = dtmc.getNumStates();
		for (int s = 0; s < numStates ; ++s) {
			double rew = actmcRew.getStateReward(s);
			if (rew > 0) {
				newRew.setStateReward(s, rew / dtmc.uniformizationRate);
			}
		}
		
		for (Map.Entry<String, ACTMCPotatoData> pdEntry : pdMap.entrySet()) {
			ACTMCPotatoData potatoData = pdEntry.getValue();
			Set<Integer> entrances = potatoData.getEntrances();
			for (int entrance : entrances) {
				double rew = potatoData.getMeanRewards().get(entrance);
				if (rew > 0) {
					double theta = potatoData.getMeanTimes().get(entrance).sum();
					double meanRew = rew / theta;//average reward over average time spent within
					newRew.setStateReward(entrance, meanRew / dtmc.uniformizationRate);
				}
			}
		}
		
		return newRew;
	}

	/**
	 * Creates a map where the keys are string identifiers of the GSMPEvents,
	 * and the values are corresponding ACTMCPotatoData structures.
	 * This is useful as to enable reusage of the ACTMCPotatoData structures efficiently.
	 * @param actmc ACTMC model for which to create the ACTMCPotatoData structures
	 * @param rew Optional rewards associated with {@code actmc}. May be null, but calls
	 *            to {@code ACTMCPotatoData.getMeanReward()} will throw an exception!
	 */
	private Map<String, ACTMCPotatoData> createPotatoDataMap(ACTMCSimple actmc,
			ACTMCRewardsSimple rew, BitSet target) throws PrismException {
		Map<String, ACTMCPotatoData> pdMap = new HashMap<String, ACTMCPotatoData>();
		List<GSMPEvent> events = actmc.getEventList();
		
		for (GSMPEvent event: events) {
			ACTMCPotatoData potatoData = new ACTMCPotatoData(actmc,
					event,
					rew,
					target);
			pdMap.put(event.getIdentifier(), potatoData);
		}
		return pdMap;
	}
	
}